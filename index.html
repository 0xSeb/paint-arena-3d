<!DOCTYPE html>
<html>
<head>
    <meta charset=utf-8>
    <title>three.js app</title>
    <style>
        body {
            /*overflow: hidden;*/
            margin: 0;
        }

        canvas {
            border: 1px solid black;
        }

        table {
            margin: auto;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
    <script type="text/javascript" src="./libs/OrbitControl.js"></script>
    <!--	<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.js"></script>-->
</head>
<body>
<div>
    <table>
        <tr>
            <td></td>
            <td>
                <canvas id="cvsA" height="512" width="512"></canvas>
            </td>
            <td></td>
        </tr>
        <tr>
            <td>
                <canvas id="cvsE" height="512" width="512"></canvas>
            </td>
            <td>
                <canvas id="cvsB" height="512" width="512"></canvas>
            </td>
            <td>
                <canvas id="cvsF" height="512" width="512"></canvas>
            </td>
        </tr>
        <tr>
            <td></td>
            <td>
                <canvas id="cvsC" height="512" width="512"></canvas>
            </td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td>
                <canvas id="cvsD" height="512" width="512"></canvas>
            </td>
            <td></td>
        </tr>
    </table>
</div>
<div>
    <canvas id="cvs3D"></canvas>
</div>
<script>
    var camera, scene, renderer, mesh, material, controls, cubeRotationX, cubeRotationY, quaternion;
    var worldAxisX = new THREE.Vector3(1, 0, 0);
    var worldAxisY = new THREE.Vector3(0, 1, 0);
    var worldAxisZ = new THREE.Vector3(0, 0, 1);

    var rotationAxis;
    var rotationValueX = 0;
    var rotationValueY = 0;
    cubeRotationX = 0;
    cubeRotationY = 0;
    const CANVAS_WIDTH = 512;
    const NUMBER_OF_CELLS = 20;
    const LINE_WIDTH = 0.01;
    // const QUARTER_ROTATION = Math.PI/2;
    const QUARTER_ROTATION = 90;
    var cvsA = document.getElementById('cvsA');
    var cvsB = document.getElementById('cvsB');
    var cvsC = document.getElementById('cvsC');
    var cvsD = document.getElementById('cvsD');
    var cvsE = document.getElementById('cvsE');
    var cvsF = document.getElementById('cvsF');


    function swap(x, y) {
        var a = x;
        x = y;
        y = a;
        return {x: x, y: y};
    }

    function rotateMovementClockwise(p) {
        var u = p.movement.up;
        var r = p.movement.right;
        var d = p.movement.down;
        var l = p.movement.left;
        p.movement.up = r;
        p.movement.right = d;
        p.movement.down = l;
        p.movement.left = u;
    }

    function rotateMovementAntiClockwise(p) {
        var u = p.movement.up;
        var r = p.movement.right;
        var d = p.movement.down;
        var l = p.movement.left;
        p.movement.up = l;
        p.movement.right = u;
        p.movement.down = r;
        p.movement.left = d;
    }

    var movement_matrix = {
        cvsA:
            {
                "l": (p, keycode) => {
                    p.canvas = cvsE;
                    p.position.x = p.position.y;
                    p.position.y = 0;
                    rotateMovementAntiClockwise(p);
                    //quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x, mesh.rotation.y, mesh.rotation.z - Math.PI / 2))
                },
                "u": (p, keycode) => {
                    p.canvas = cvsD;
                    p.position.y = NUMBER_OF_CELLS - 1;

                    /*switch (keycode) {
                        case 37:
                        case 81:
                            // LEFT
                            quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x, mesh.rotation.y + Math.PI / 2, mesh.rotation.z))
                            break;
                        case 38:
                        case 90:
                            // UP
                            mesh.rotateOnWorldAxis(worldAxisX, THREE.Math.degToRad(1));
                            //quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x + Math.PI / 2, mesh.rotation.y, mesh.rotation.z))


                            break;
                    }*/
                    // quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x + Math.PI / 2, mesh.rotation.y, mesh.rotation.z))

                },
                "r": (p, keycode) => {
                    p.canvas = cvsF;
                    p.position.x = NUMBER_OF_CELLS - 1 - p.position.y;
                    p.position.y = 0;
                    rotateMovementClockwise(p);
                    quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x, mesh.rotation.y, mesh.rotation.z + Math.PI / 2))
                },
                "d": (p, keycode) => {
                    p.canvas = cvsB;
                    p.position.y = 0;
                    // TODO VARIABILISER LES 0 pi:2 ETC PARCE QUE CA DEPEND DE LA FACE DE DEPART DU JOUEUR
                    //quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x - Math.PI / 2, mesh.rotation.y, mesh.rotation.z))

                },

            },
        cvsB:
            {
                "l": (p, keycode) => {
                    p.canvas = cvsE;
                    p.position.x = NUMBER_OF_CELLS - 1;
                    // quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI/2 );
                   // quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x, mesh.rotation.y + Math.PI / 2, mesh.rotation.z));

                },
                "u": (p, keycode) => {
                    p.canvas = cvsA;
                    p.position.y = NUMBER_OF_CELLS - 1;

                    // quaternion.setFromAxisAngle( new THREE.Vector3( 1, 0, 0 ), Math.PI / 2 );
                    // switch (keycode) {
                    //     case 37:
                    //     case 81:
                    // LEFT
                    // quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI);
                    // break;
                    // case 38:
                    // case 90:
                    // UP
                    // quaternion.setFromAxisAngle( new THREE.Vector3( 1, 0, 0 ), Math.PI / 2 );
                    // break;
                    // }
                  //  quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x + Math.PI / 2, mesh.rotation.y, mesh.rotation.z))
                },
                "r": (p, keycode) => {
                    p.canvas = cvsF;
                    p.position.x = 0;
                    quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x, mesh.rotation.y - Math.PI / 2, mesh.rotation.z))
                },
                "d": (p, keycode) => {
                    p.canvas = cvsC;
                    p.position.y = 0;
                    quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x - Math.PI / 2, mesh.rotation.y, mesh.rotation.z))
                },
                quaternion: 0,
            },
        cvsC:
            {
                "l": (p, keycode) => {
                    p.canvas = cvsE;
                    p.position.x = NUMBER_OF_CELLS - 1 - p.position.y;
                    p.position.y = NUMBER_OF_CELLS - 1;
                    rotateMovementClockwise(p);
                    quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x, mesh.rotation.y, mesh.rotation.z + Math.PI / 2))
                },
                "u": (p, keycode) => {
                    p.canvas = cvsB;
                    p.position.y = NUMBER_OF_CELLS - 1;
                    quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x + Math.PI / 2, mesh.rotation.y, mesh.rotation.z))
                },
                "r": (p, keycode) => {
                    p.canvas = cvsF;
                    var {x, y} = swap(p.position.x, p.position.y);
                    p.position.x = x;
                    p.position.y = y;
                    rotateMovementAntiClockwise(p);
                    quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x, mesh.rotation.y, mesh.rotation.z - Math.PI / 2))
                },
                "d": (p, keycode) => {
                    p.canvas = cvsD;
                    p.position.y = 0;
                    // quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x - Math.PI / 2, mesh.rotation.y, mesh.rotation.z))


                },

            },
        cvsD:
            {
                "l": (p, keycode) => {
                    p.canvas = cvsE;
                    p.position.x = 0;
                    p.position.y = NUMBER_OF_CELLS - 1 - p.position.y;
                    rotateMovementClockwise(p);
                    rotateMovementClockwise(p);
                    //quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x, mesh.rotation.y + Math.PI / 2, mesh.rotation.z));

                },
                "u": (p, keycode) => {
                    p.canvas = cvsC;
                    p.position.y = NUMBER_OF_CELLS - 1;
                    quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x + Math.PI / 2, mesh.rotation.y, mesh.rotation.z))

                },
                "r": (p, keycode) => {
                    p.canvas = cvsF;
                    p.position.x = NUMBER_OF_CELLS - 1;
                    p.position.y = NUMBER_OF_CELLS - 1 - p.position.y;
                    rotateMovementClockwise(p);
                    rotateMovementClockwise(p);
                    quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x, mesh.rotation.y - Math.PI / 2, mesh.rotation.z));
                },
                "d": (p, keycode) => {
                    p.canvas = cvsA;
                    p.position.y = 0;
                    switch (keycode) {
                        case 37:
                        case 81:
                            // LEFT
                            quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x + Math.PI / 2, mesh.rotation.y, mesh.rotation.z))
                            break;
                        case 38:
                        case 90:
                            // UP
                            quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x + Math.PI / 2, mesh.rotation.y, mesh.rotation.z))
                            break;
                        case 39:
                        case 68:
                            // RIGHT
                            quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x + Math.PI / 2, mesh.rotation.y, mesh.rotation.z))
                            break;
                        case 40:
                        case 83:
                            // DOWN
                            quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x + Math.PI / 2, mesh.rotation.y, mesh.rotation.z))
                            break;
                    }
                },
                quaternion: Math.PI,
            },
        cvsE:
            {
                "l": (p, keycode) => {
                    p.canvas = cvsD;
                    p.position.y = NUMBER_OF_CELLS - 1 - p.position.y;
                    p.position.x = 0;
                    rotateMovementClockwise(p);
                    rotateMovementClockwise(p);
                    // switch (keycode) {
                    //     case 37:
                    //     case 81:
                    //     LEFT
                    // quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI);
                    // break;
                    // case 38:
                    // case 90:
                    // UP
                    // quaternion.setFromAxisAngle( new THREE.Vector3( 0.5, 0.5, 0 ), Math.PI);
                    // break;
                    // }

                    quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x, mesh.rotation.y + Math.PI / 2, mesh.rotation.z));

                },
                "u": (p, keycode) => {
                    p.canvas = cvsA;
                    p.position.y = p.position.x;
                    p.position.x = 0;
                    rotateMovementClockwise(p);
                    quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x, mesh.rotation.y, mesh.rotation.z + Math.PI / 2))
                },
                "r": (p, keycode) => {
                    p.canvas = cvsB;
                    p.position.x = 0;


                   /* switch (keycode) {
                        case 37:
                        case 81:
                            // LEFT
                            quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x + Math.PI / 2, mesh.rotation.y, mesh.rotation.z))
                            break;
                        case 38:
                        case 90:
                            // UP
                            quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x + Math.PI / 2, mesh.rotation.y, mesh.rotation.z))
                            break;
                        case 39:
                        case 68:
                            // RIGHT
                            quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x, mesh.rotation.y - Math.PI / 2, mesh.rotation.z))
                            break;
                        case 40:
                        case 83:
                            // DOWN
                            quaternion.setFromEuler(new THREE.Euler( Math.PI / 2, -Math.PI / 2, -Math.PI / 2, "XZY"))
                            break;
                    }*/

                },
                "d": (p, keycode) => {
                    p.canvas = cvsC;
                    p.position.y = NUMBER_OF_CELLS - 1 - p.position.x;
                    p.position.x = 0;
                    rotateMovementAntiClockwise(p);
                    quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x, mesh.rotation.y, mesh.rotation.z - Math.PI / 2))

                },
            },
        cvsF:
            {
                "l": (p, keycode) => {
                    p.canvas = cvsB;
                    p.position.x = NUMBER_OF_CELLS - 1;
                    quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x, mesh.rotation.y + Math.PI / 2, mesh.rotation.z))
                },
                "u": (p, keycode) => {
                    p.canvas = cvsA;
                    p.position.y = NUMBER_OF_CELLS - 1 - p.position.x;
                    p.position.x = NUMBER_OF_CELLS - 1;
                    rotateMovementAntiClockwise(p);
                    quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x, mesh.rotation.y, mesh.rotation.z - Math.PI / 2))
                },
                "r": (p, keycode) => {
                    p.canvas = cvsD;
                    p.position.y = NUMBER_OF_CELLS - 1 - p.position.y;
                    p.position.x = NUMBER_OF_CELLS - 1;
                    rotateMovementAntiClockwise(p);
                    rotateMovementAntiClockwise(p);
                    quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x, mesh.rotation.y - Math.PI / 2, mesh.rotation.z))
                },
                "d": (p, keycode) => {
                    p.canvas = cvsC;
                    p.position.y = p.position.x;
                    // var {x, y} = swap(p.position.x, p.position.y);
                    p.position.x = NUMBER_OF_CELLS - 1;
                    rotateMovementClockwise(p);
                    quaternion.setFromEuler(new THREE.Euler(mesh.rotation.x, mesh.rotation.y, mesh.rotation.z + Math.PI / 2))
                },
            }
    };

    var activeCanvas = cvsB;

    var ctx = cvsB.getContext('2d');
    var cellWidth = CANVAS_WIDTH / NUMBER_OF_CELLS;

    for (x = 0; x <= ctx.canvas.width; x += cellWidth) {
        ctx.moveTo(x, 0);
        ctx.lineTo(x, ctx.canvas.height);
        for (y = 0; y <= ctx.canvas.height; y += cellWidth) {
            ctx.moveTo(0, y);
            ctx.lineTo(ctx.canvas.width, y);
        }
    }
    ctx.lineWidth = LINE_WIDTH;
    ctx.stroke();


    function fillCellColor(player) {
        var innerCellWidth = CANVAS_WIDTH / NUMBER_OF_CELLS - LINE_WIDTH;
        var ctx = player.canvas.getContext('2d');
        ctx.fillStyle = player.color;
        ctx.fillRect(player.position.x * cellWidth, player.position.y * cellWidth, cellWidth, cellWidth);

        ctx.strokeStyle = "black";
        ctx.lineWidth = 1;
        ctx.strokeRect(player.position.x * cellWidth, player.position.y * cellWidth, cellWidth, cellWidth);


        material.forEach(mat => {
            mat.map.needsUpdate = true;
        });


        //mesh.needsUpdate = true;
    }

    document.onkeydown = function (event) {
        // PLAYER 2 joue avec les flèches
        if ([37, 38, 39, 40].includes(event.keyCode)) {
            movePlayer(player2, event.keyCode);
        }
        // PLAYER 1 joue avec zqsd
        if ([90, 81, 83, 68].includes(event.keyCode)) {
            movePlayer(player1, event.keyCode);
        }

    };


    function buildPlayer(color, canvas) {
        return {
            color: color,
            canvas: canvas,
            // TODO variabiliser cette partie
            position: {
                x: 2,
                y: 2,
            },
            movement: {
                left: "l",
                right: "r",
                up: "u",
                down: "d"
            }
        }
    }

    function drawGridOnCanvas(canvas) {
        var ctx = canvas.getContext('2d');
        var cellWidth = CANVAS_WIDTH / NUMBER_OF_CELLS;

        for (x = 0; x <= ctx.canvas.width; x += cellWidth) {
            for (y = 0; y <= ctx.canvas.height; y += cellWidth) {
                ctx.moveTo(x, y);
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(x, y, x + cellWidth, y + cellWidth);

                ctx.strokeStyle = "#000000";
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, x + cellWidth, y + cellWidth);
            }
        }
    }

    function updatePlayerCoordinates(player, movement) {
        switch (movement) {
            case "l":
                player.position.x -= 1;
                break;
            case "u":
                player.position.y -= 1;
                break;
            case "r":
                player.position.x += 1;
                break;
            case "d":
                player.position.y += 1;
                break;
        }
    }

    function movePlayer(player, keycode) {
        // ici c'est quand on atteint le bord de la grille
        /*var newActiveCanvas = movement_matrix[activeCanvas.id][event.keyCode];
        fillCellColor(newActiveCanvas, 'orange')
        activeCanvas = newActiveCanvas;*/

        // ON LE BOUGE SUR LE CANVAS SAUF SI ON DEPASSE SES LIMITES ON CHANGE DE CANVAS
        var movement = "";
        // TODO VERIFIER COLISIONS PLAYER
        switch (keycode) {
            case 37:
            case 81:
                // LEFT
                movement = player.movement.left;
                updatePlayerCoordinates(player, movement);
                if (leaveCanvas(player)) {
                    // calculer sa position avant
                    //player.canvas = movement_matrix[player.canvas.id][movement];
                    movement_matrix[player.canvas.id][movement](player, keycode);
                    // peindre la cell ?
                    rotationAxis = worldAxisY;
                    rotationValueY += 90;
                }

                fillCellColor(player);
                break;
            case 38:
            case 90:
                // UP
                movement = player.movement.up;
                updatePlayerCoordinates(player, movement);
                if (leaveCanvas(player)) {
                    // calculer sa position avant
                    //player.canvas = movement_matrix[player.canvas.id][movement];
                    movement_matrix[player.canvas.id][movement](player, keycode);
                    rotationAxis = worldAxisX;
                    rotationValueX += 90;
                    // peindre la cell ?
                }

                fillCellColor(player);
                break;
            case 39:
            case 68:
                // RIGHT
                movement = player.movement.right;
                updatePlayerCoordinates(player, movement);
                if (leaveCanvas(player)) {
                    // calculer sa position avant
                    //player.canvas = movement_matrix[player.canvas.id][movement];
                    movement_matrix[player.canvas.id][movement](player, keycode);
                    // peindre la cell ?
                    rotationAxis = worldAxisY;
                    rotationValueY -= 90;
                }

                fillCellColor(player);
                break;
            case 40:
            case 83:
                // DOWN
                movement = player.movement.down;
                updatePlayerCoordinates(player, movement);
                if (leaveCanvas(player)) {
                    // calculer sa position avant
                    //player.canvas = movement_matrix[player.canvas.id][movement];
                    movement_matrix[player.canvas.id][movement](player, keycode);
                    // peindre la cell ?
                    rotationAxis = worldAxisX;
                    rotationValueX -=90;
                }

                fillCellColor(player);
                break;
            default:
                return;
        }


    }

    function leaveCanvas(player) {
        if (player.position.x < 0 || player.position.x >= NUMBER_OF_CELLS || player.position.y < 0 || player.position.y >= NUMBER_OF_CELLS) {
            return true;
        }
        return false;
    }


    var player1 = buildPlayer('orange', cvsB);
    var player2 = buildPlayer('red', cvsA);
    var player3 = buildPlayer('blue', cvsD);
    var player4 = buildPlayer('green', cvsC);
    var player5 = buildPlayer('black', cvsE);
    drawGridOnCanvas(cvsA);
    drawGridOnCanvas(cvsB);
    drawGridOnCanvas(cvsC);
    drawGridOnCanvas(cvsD);
    drawGridOnCanvas(cvsE);
    drawGridOnCanvas(cvsF);
    init();

    fillCellColor(player1);
    fillCellColor(player2);
    fillCellColor(player3);
    fillCellColor(player4);
    fillCellColor(player5);

    animate();

    function init() {

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
        camera.position.x = -200;
        camera.position.y = 200;
        camera.position.z = 500;

        scene = new THREE.Scene();
        var backFace = new THREE.CanvasTexture(cvsD);
        backFace.center = new THREE.Vector2(0.5, 0.5);
        backFace.rotation = Math.PI;

        material = [
            new THREE.MeshBasicMaterial({
                map: new THREE.CanvasTexture(cvsF)
            }),
            new THREE.MeshBasicMaterial({
                map: new THREE.CanvasTexture(cvsE)
            }),
            new THREE.MeshBasicMaterial({
                map: new THREE.CanvasTexture(cvsA)
            }),
            new THREE.MeshBasicMaterial({
                map: new THREE.CanvasTexture(cvsC)
            }),
            new THREE.MeshBasicMaterial({
                map: new THREE.CanvasTexture(cvsB)
            }),
            new THREE.MeshBasicMaterial({
                map: backFace
            })

        ];
        mesh = new THREE.Mesh(new THREE.BoxBufferGeometry(200, 200, 200), material);
        var axes = new THREE.AxesHelper(250);
        mesh.add(axes);
        scene.add(mesh);

        quaternion = new THREE.Quaternion();

        renderer = new THREE.WebGLRenderer({antialias: true, canvas: document.getElementById('cvs3D')});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        camera.lookAt(mesh.position);

        window.addEventListener('resize', onWindowResize, false);

        // Création du contrôleur
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.minDistance = 200;
        controls.maxDistance = 1000;
    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

    }


    function animate() {
        controls.update();

       /* if (!mesh.quaternion.equals(quaternion)) {
            mesh.quaternion.rotateTowards(quaternion, 0.05);
        }*/

        /* material.forEach(mat => {
            console.log(mat.needsUpdate);
         });*/
        /* if (cubeRotationX >= 360) cubeRotationX = 0;
         if (cubeRotationY >= 360) cubeRotationY = 0;
         console.log(mesh.rotation.x, cubeRotationX);


         if (cubeRotationX <= 180) {
             if (THREE.Math.radToDeg(mesh.rotation.x) < cubeRotationX + 0.6 && THREE.Math.radToDeg(mesh.rotation.x) > cubeRotationX - 0.6) {
                 mesh.rotation.x = THREE.Math.degToRad(cubeRotationX);
             } else {
                 mesh.rotateX(0.01);
             }
         } else {
             if (360 - Math.abs(THREE.Math.radToDeg(mesh.rotation.x)) > 268 && 360 - Math.abs(THREE.Math.radToDeg(mesh.rotation.x)) < 272) {
                 mesh.rotation.x =  THREE.Math.degToRad(270);
             }
             if (360 - Math.abs(THREE.Math.radToDeg(mesh.rotation.x)) < cubeRotationX + 0.6 && 360 - Math.abs(THREE.Math.radToDeg(mesh.rotation.x)) > cubeRotationX - 0.6) {
                 mesh.rotation.x = THREE.Math.degToRad(cubeRotationX);
             } else {
                 mesh.rotateX(0.01);
             }
         }

         if (cubeRotationY <= 180) {
             if (THREE.Math.radToDeg(mesh.rotation.y) < cubeRotationY + 0.6 && THREE.Math.radToDeg(mesh.rotation.y) > cubeRotationY - 0.6) {
                 mesh.rotation.y = THREE.Math.degToRad(cubeRotationY);
             } else {
                 mesh.rotateY(0.01);
             }
         } else {
             if (360 - Math.abs(THREE.Math.radToDeg(mesh.rotation.y)) > 268 && 360 - Math.abs(THREE.Math.radToDeg(mesh.rotation.y)) < 272) {
                 mesh.rotation.y =  THREE.Math.degToRad(270);
             }
             if (360 - Math.abs(THREE.Math.radToDeg(mesh.rotation.y)) < cubeRotationY + 0.6 && 360 - Math.abs(THREE.Math.radToDeg(mesh.rotation.y)) > cubeRotationY - 0.6) {
                 mesh.rotation.y = THREE.Math.degToRad(cubeRotationY);
             } else {
                 mesh.rotateY(0.01);
             }
         }
 */
        /*if(mesh.rotation.x > 0 && mesh.rotation.x < Math.PI){
            if (mes.rotation.x < cubeRotationX)
            if(Math.abs(mesh.rotation.x) < cubeRotationX + 0.02 && Math.abs(mesh.rotation.x) > cubeRotationX - 0.02){
                mesh.rotation.x = cubeRotationX;
            }else{
                mesh.rotateX(0.01);
            }
        }else if(mesh.rotation.x > cubeRotationX){
            mesh.rotateX(-0.01);
        }
        if(mesh.rotation.y < cubeRotationY ){
            mesh.rotateY(0.01);
        }else if(mesh.rotation.y > cubeRotationY){
            mesh.rotateY(-0.01);
        }*/
        if(rotationValueX !== 0){
            if(rotationValueX > 0) {
                mesh.rotateOnWorldAxis(rotationAxis, THREE.Math.degToRad(3));
                rotationValueX-=3;
            }else if(rotationValueX <0){
                mesh.rotateOnWorldAxis(rotationAxis, THREE.Math.degToRad(-3));
                rotationValueX+=3;
            }
        }

        if(rotationValueY !== 0){
            if(rotationValueY > 0) {
                mesh.rotateOnWorldAxis(rotationAxis, THREE.Math.degToRad(3));
                rotationValueY-=3;
            }else if(rotationValueY <0){
                mesh.rotateOnWorldAxis(rotationAxis, THREE.Math.degToRad(-3));
                rotationValueY+=3;
            }
        }

        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }


</script>
</body>
</html>