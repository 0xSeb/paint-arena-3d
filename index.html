<!DOCTYPE html>
<html>
<head>
    <meta charset=utf-8>
    <title>three.js app</title>
    <style>
        body {
            /*overflow: hidden;*/
            margin: 0;
        }

        canvas {
            border: 1px solid black;
        }

        table {
            margin: auto;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
    <script type="text/javascript" src="./libs/OrbitControl.js"></script>
    <!--	<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.js"></script>-->
</head>
<body>
<div>
    <table>
        <tr>
            <td></td>
            <td>
                <canvas id="cvsA" height="512" width="512"></canvas>
            </td>
            <td></td>
        </tr>
        <tr>
            <td>
                <canvas id="cvsE" height="512" width="512"></canvas>
            </td>
            <td>
                <canvas id="cvsB" height="512" width="512"></canvas>
            </td>
            <td>
                <canvas id="cvsF" height="512" width="512"></canvas>
            </td>
        </tr>
        <tr>
            <td></td>
            <td>
                <canvas id="cvsC" height="512" width="512"></canvas>
            </td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td>
                <canvas id="cvsD" height="512" width="512"></canvas>
            </td>
            <td></td>
        </tr>
    </table>
</div>
<div>
    <canvas id="cvs3D"></canvas>
</div>
<script>
    var camera, scene, renderer, mesh, material, controls, cubeRotationX, cubeRotationY;
    var worldAxisX = new THREE.Vector3(1, 0, 0);
    var worldAxisY = new THREE.Vector3(0, 1, 0);
    var worldAxisZ = new THREE.Vector3(0, 0, 1);

    var rotationAxis;
    var rotationValueX = 0;
    var rotationValueY = 0;
    cubeRotationX = 0;
    cubeRotationY = 0;
    const CANVAS_WIDTH = 512;
    const NUMBER_OF_CELLS = 20;
    const LINE_WIDTH = 0.01;

    var cvsA = document.getElementById('cvsA');
    var cvsB = document.getElementById('cvsB');
    var cvsC = document.getElementById('cvsC');
    var cvsD = document.getElementById('cvsD');
    var cvsE = document.getElementById('cvsE');
    var cvsF = document.getElementById('cvsF');


    function swap(x, y) {
        var a = x;
        x = y;
        y = a;
        return {x: x, y: y};
    }

    function rotateMovementClockwise(p) {
        var u = p.movement.up;
        var r = p.movement.right;
        var d = p.movement.down;
        var l = p.movement.left;
        p.movement.up = r;
        p.movement.right = d;
        p.movement.down = l;
        p.movement.left = u;
    }

    function rotateMovementAntiClockwise(p) {
        var u = p.movement.up;
        var r = p.movement.right;
        var d = p.movement.down;
        var l = p.movement.left;
        p.movement.up = l;
        p.movement.right = u;
        p.movement.down = r;
        p.movement.left = d;
    }

    var movement_matrix = {
        cvsA:
            {
                "l": (p, keycode) => {
                    p.canvas = cvsE;
                    p.position.x = p.position.y;
                    p.position.y = 0;
                    rotateMovementAntiClockwise(p);
                },
                "u": (p, keycode) => {
                    p.canvas = cvsD;
                    p.position.y = NUMBER_OF_CELLS - 1;

                },
                "r": (p, keycode) => {
                    p.canvas = cvsF;
                    p.position.x = NUMBER_OF_CELLS - 1 - p.position.y;
                    p.position.y = 0;
                    rotateMovementClockwise(p);
                },
                "d": (p, keycode) => {
                    p.canvas = cvsB;
                    p.position.y = 0;
                    // TODO VARIABILISER LES 0 pi:2 ETC PARCE QUE CA DEPEND DE LA FACE DE DEPART DU JOUEUR

                },

            },
        cvsB:
            {
                "l": (p, keycode) => {
                    p.canvas = cvsE;
                    p.position.x = NUMBER_OF_CELLS - 1;
                },
                "u": (p, keycode) => {
                    p.canvas = cvsA;
                    p.position.y = NUMBER_OF_CELLS - 1;
                },
                "r": (p, keycode) => {
                    p.canvas = cvsF;
                    p.position.x = 0;
                },
                "d": (p, keycode) => {
                    p.canvas = cvsC;
                    p.position.y = 0;
                },
            },
        cvsC:
            {
                "l": (p, keycode) => {
                    p.canvas = cvsE;
                    p.position.x = NUMBER_OF_CELLS - 1 - p.position.y;
                    p.position.y = NUMBER_OF_CELLS - 1;
                    rotateMovementClockwise(p);
                },
                "u": (p, keycode) => {
                    p.canvas = cvsB;
                    p.position.y = NUMBER_OF_CELLS - 1;
                },
                "r": (p, keycode) => {
                    p.canvas = cvsF;
                    var {x, y} = swap(p.position.x, p.position.y);
                    p.position.x = x;
                    p.position.y = y;
                    rotateMovementAntiClockwise(p);
                },
                "d": (p, keycode) => {
                    p.canvas = cvsD;
                    p.position.y = 0;
                },

            },
        cvsD:
            {
                "l": (p, keycode) => {
                    p.canvas = cvsE;
                    p.position.x = 0;
                    p.position.y = NUMBER_OF_CELLS - 1 - p.position.y;
                    rotateMovementClockwise(p);
                    rotateMovementClockwise(p);

                },
                "u": (p, keycode) => {
                    p.canvas = cvsC;
                    p.position.y = NUMBER_OF_CELLS - 1;

                },
                "r": (p, keycode) => {
                    p.canvas = cvsF;
                    p.position.x = NUMBER_OF_CELLS - 1;
                    p.position.y = NUMBER_OF_CELLS - 1 - p.position.y;
                    rotateMovementClockwise(p);
                    rotateMovementClockwise(p);
                },
                "d": (p, keycode) => {
                    p.canvas = cvsA;
                    p.position.y = 0;
                },
            },
        cvsE:
            {
                "l": (p, keycode) => {
                    p.canvas = cvsD;
                    p.position.y = NUMBER_OF_CELLS - 1 - p.position.y;
                    p.position.x = 0;
                    rotateMovementClockwise(p);
                    rotateMovementClockwise(p);
                },
                "u": (p, keycode) => {
                    p.canvas = cvsA;
                    p.position.y = p.position.x;
                    p.position.x = 0;
                    rotateMovementClockwise(p);
                },
                "r": (p, keycode) => {
                    p.canvas = cvsB;
                    p.position.x = 0;
                },
                "d": (p, keycode) => {
                    p.canvas = cvsC;
                    p.position.y = NUMBER_OF_CELLS - 1 - p.position.x;
                    p.position.x = 0;
                    rotateMovementAntiClockwise(p);

                },
            },
        cvsF:
            {
                "l": (p, keycode) => {
                    p.canvas = cvsB;
                    p.position.x = NUMBER_OF_CELLS - 1;
                },
                "u": (p, keycode) => {
                    p.canvas = cvsA;
                    p.position.y = NUMBER_OF_CELLS - 1 - p.position.x;
                    p.position.x = NUMBER_OF_CELLS - 1;
                    rotateMovementAntiClockwise(p);
                },
                "r": (p, keycode) => {
                    p.canvas = cvsD;
                    p.position.y = NUMBER_OF_CELLS - 1 - p.position.y;
                    p.position.x = NUMBER_OF_CELLS - 1;
                    rotateMovementAntiClockwise(p);
                    rotateMovementAntiClockwise(p);
                },
                "d": (p, keycode) => {
                    p.canvas = cvsC;
                    p.position.y = p.position.x;
                    p.position.x = NUMBER_OF_CELLS - 1;
                    rotateMovementClockwise(p);
                },
            }
    };

    var ctx = cvsB.getContext('2d');
    var cellWidth = CANVAS_WIDTH / NUMBER_OF_CELLS;

    for (x = 0; x <= ctx.canvas.width; x += cellWidth) {
        ctx.moveTo(x, 0);
        ctx.lineTo(x, ctx.canvas.height);
        for (y = 0; y <= ctx.canvas.height; y += cellWidth) {
            ctx.moveTo(0, y);
            ctx.lineTo(ctx.canvas.width, y);
        }
    }
    ctx.lineWidth = LINE_WIDTH;
    ctx.stroke();


    function fillCellColor(player) {
        var ctx = player.canvas.getContext('2d');
        ctx.fillStyle = player.color;
        ctx.fillRect(player.position.x * cellWidth, player.position.y * cellWidth, cellWidth, cellWidth);

        ctx.strokeStyle = "black";
        ctx.lineWidth = 1;
        ctx.strokeRect(player.position.x * cellWidth, player.position.y * cellWidth, cellWidth, cellWidth);


        material.forEach(mat => {
            mat.map.needsUpdate = true;
        });

    }

    document.onkeydown = function (event) {
        // PLAYER 2 joue avec les flèches
        if ([37, 38, 39, 40].includes(event.keyCode)) {
            movePlayer(player2, event.keyCode);
        }
        // PLAYER 1 joue avec zqsd
        if ([90, 81, 83, 68].includes(event.keyCode)) {
            movePlayer(player1, event.keyCode);
        }

    };


    function buildPlayer(color, canvas) {
        return {
            color: color,
            canvas: canvas,
            // TODO variabiliser cette partie
            position: {
                x: 2,
                y: 2,
            },
            movement: {
                left: "l",
                right: "r",
                up: "u",
                down: "d"
            }
        }
    }

    function drawGridOnCanvas(canvas) {
        var ctx = canvas.getContext('2d');
        var cellWidth = CANVAS_WIDTH / NUMBER_OF_CELLS;

        for (x = 0; x <= ctx.canvas.width; x += cellWidth) {
            for (y = 0; y <= ctx.canvas.height; y += cellWidth) {
                ctx.moveTo(x, y);
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(x, y, x + cellWidth, y + cellWidth);

                ctx.strokeStyle = "#000000";
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, x + cellWidth, y + cellWidth);
            }
        }
    }

    function updatePlayerCoordinates(player, movement) {
        switch (movement) {
            case "l":
                player.position.x -= 1;
                break;
            case "u":
                player.position.y -= 1;
                break;
            case "r":
                player.position.x += 1;
                break;
            case "d":
                player.position.y += 1;
                break;
        }
    }

    function movePlayer(player, keycode) {
        var movement = "";
        // TODO VERIFIER COLISIONS PLAYER
        switch (keycode) {
            case 37:
            case 81:
                // LEFT
                movement = player.movement.left;
                updatePlayerCoordinates(player, movement);
                if (leaveCanvas(player)) {
                    movement_matrix[player.canvas.id][movement](player, keycode);
                    rotationAxis = worldAxisY;
                    rotationValueY += 90;
                }

                fillCellColor(player);
                break;
            case 38:
            case 90:
                // UP
                movement = player.movement.up;
                updatePlayerCoordinates(player, movement);
                if (leaveCanvas(player)) {
                    movement_matrix[player.canvas.id][movement](player, keycode);
                    rotationAxis = worldAxisX;
                    rotationValueX += 90;
                }

                fillCellColor(player);
                break;
            case 39:
            case 68:
                // RIGHT
                movement = player.movement.right;
                updatePlayerCoordinates(player, movement);
                if (leaveCanvas(player)) {
                    movement_matrix[player.canvas.id][movement](player, keycode);
                    rotationAxis = worldAxisY;
                    rotationValueY -= 90;
                }

                fillCellColor(player);
                break;
            case 40:
            case 83:
                // DOWN
                movement = player.movement.down;
                updatePlayerCoordinates(player, movement);
                if (leaveCanvas(player)) {
                    movement_matrix[player.canvas.id][movement](player, keycode);
                    rotationAxis = worldAxisX;
                    rotationValueX -= 90;
                }

                fillCellColor(player);
                break;
            default:
                return;
        }


    }

    function leaveCanvas(player) {
        if (player.position.x < 0 || player.position.x >= NUMBER_OF_CELLS || player.position.y < 0 || player.position.y >= NUMBER_OF_CELLS) {
            return true;
        }
        return false;
    }


    var player1 = buildPlayer('orange', cvsB);
    var player2 = buildPlayer('red', cvsA);
    var player3 = buildPlayer('blue', cvsD);
    var player4 = buildPlayer('green', cvsC);
    var player5 = buildPlayer('black', cvsE);
    drawGridOnCanvas(cvsA);
    drawGridOnCanvas(cvsB);
    drawGridOnCanvas(cvsC);
    drawGridOnCanvas(cvsD);
    drawGridOnCanvas(cvsE);
    drawGridOnCanvas(cvsF);
    init();

    fillCellColor(player1);
    fillCellColor(player2);
    fillCellColor(player3);
    fillCellColor(player4);
    fillCellColor(player5);

    animate();

    function init() {

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
        camera.position.x = -200;
        camera.position.y = 200;
        camera.position.z = 500;

        scene = new THREE.Scene();
        var backFace = new THREE.CanvasTexture(cvsD);
        backFace.center = new THREE.Vector2(0.5, 0.5);
        backFace.rotation = Math.PI;

        material = [
            new THREE.MeshBasicMaterial({
                map: new THREE.CanvasTexture(cvsF)
            }),
            new THREE.MeshBasicMaterial({
                map: new THREE.CanvasTexture(cvsE)
            }),
            new THREE.MeshBasicMaterial({
                map: new THREE.CanvasTexture(cvsA)
            }),
            new THREE.MeshBasicMaterial({
                map: new THREE.CanvasTexture(cvsC)
            }),
            new THREE.MeshBasicMaterial({
                map: new THREE.CanvasTexture(cvsB)
            }),
            new THREE.MeshBasicMaterial({
                map: backFace
            })

        ];
        mesh = new THREE.Mesh(new THREE.BoxBufferGeometry(200, 200, 200), material);
        var axes = new THREE.AxesHelper(250);
        mesh.add(axes);
        scene.add(mesh);


        renderer = new THREE.WebGLRenderer({antialias: true, canvas: document.getElementById('cvs3D')});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        camera.lookAt(mesh.position);

        window.addEventListener('resize', onWindowResize, false);

        // Création du contrôleur
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.minDistance = 200;
        controls.maxDistance = 1000;
    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

    }


    function animate() {
        controls.update();

        if (rotationValueX !== 0) {
            if (rotationValueX > 0) {
                mesh.rotateOnWorldAxis(rotationAxis, THREE.Math.degToRad(3));
                rotationValueX -= 3;
            } else if (rotationValueX < 0) {
                mesh.rotateOnWorldAxis(rotationAxis, THREE.Math.degToRad(-3));
                rotationValueX += 3;
            }
        }

        if (rotationValueY !== 0) {
            if (rotationValueY > 0) {
                mesh.rotateOnWorldAxis(rotationAxis, THREE.Math.degToRad(3));
                rotationValueY -= 3;
            } else if (rotationValueY < 0) {
                mesh.rotateOnWorldAxis(rotationAxis, THREE.Math.degToRad(-3));
                rotationValueY += 3;
            }
        }

        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }


</script>
</body>
</html>